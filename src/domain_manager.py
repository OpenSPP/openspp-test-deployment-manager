# ABOUTME: Domain and Nginx configuration manager for deployment subdomains
# ABOUTME: Handles automatic nginx config generation and SSL setup with per-deployment auth

import os
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional
import tempfile
import shutil

from src.models import Deployment, AppConfig
from src.utils import run_command

logger = logging.getLogger(__name__)


class DomainManager:
    """Manage subdomain configuration and Nginx setup"""
    
    def __init__(self, config: AppConfig):
        self.config = config
        self.nginx_sites_path = Path(config.nginx_config_path)
        self.nginx_enabled_path = self.nginx_sites_path.parent / "sites-enabled"
    
    def generate_subdomain(self, deployment_id: str) -> str:
        """Generate subdomain for deployment"""
        # Simple subdomain: deployment-id.base-domain
        return f"{deployment_id}.{self.config.base_domain}"
    
    def create_htpasswd_file(self, deployment: Deployment) -> bool:
        """Create htpasswd file for basic auth"""
        if not deployment.auth_password:
            logger.warning(f"No auth password for deployment {deployment.id}")
            return False
            
        htpasswd_path = Path(f"/etc/nginx/htpasswd-{deployment.id}")
        
        try:
            # Generate APR1-MD5 hash (nginx compatible)
            import crypt
            # Use deployment.id as username
            username = deployment.id
            # Create htpasswd entry
            htpasswd_entry = f"{username}:{crypt.crypt(deployment.auth_password, crypt.mksalt(crypt.METHOD_MD5))}\n"
            
            # Write to temporary file first
            with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp:
                tmp.write(htpasswd_entry)
                tmp_path = tmp.name
            
            # Move to nginx directory (requires sudo)
            result = run_command(
                ["sudo", "mv", tmp_path, str(htpasswd_path)]
            )
            
            if result.returncode != 0:
                logger.error(f"Failed to save htpasswd file: {result.stderr}")
                if os.path.exists(tmp_path):
                    os.unlink(tmp_path)
                return False
            
            # Set proper permissions
            run_command(["sudo", "chmod", "644", str(htpasswd_path)])
            
            logger.info(f"Created htpasswd file for {deployment.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to create htpasswd file: {e}")
            return False
    
    def generate_nginx_config(self, deployment: Deployment) -> str:
        """Generate Nginx reverse proxy configuration with auth for external domains only"""
        external_domain = deployment.subdomain  # e.g., test1.test.openspp.org
        internal_domain = f"{deployment.id}.openspp-test.internal"  # e.g., penn-qa-farmer.openspp-test.internal
        odoo_port = deployment.port_mappings['odoo']
        smtp_port = deployment.port_mappings.get('smtp', deployment.port_base + 25)
        pgweb_port = deployment.port_mappings.get('pgweb', deployment.port_base + 81)
        
        # Common proxy configuration
        proxy_config = f"""
        proxy_pass http://localhost:{odoo_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_redirect off;
        client_max_body_size 100M;"""
        
        websocket_config = f"""
        proxy_pass http://localhost:{odoo_port}/websocket;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;"""
        
        config = f"""# Auto-generated Nginx configuration for {deployment.id}
# Generated by OpenSPP Deployment Manager

# ===== EXTERNAL DOMAIN WITH AUTHENTICATION =====
server {{
    listen 80;
    server_name {external_domain};
    
    # Basic authentication (username: {deployment.id})
    auth_basic "OpenSPP Deployment {deployment.id}";
    auth_basic_user_file /etc/nginx/htpasswd-{deployment.id};
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Proxy timeouts
    proxy_connect_timeout 600s;
    proxy_send_timeout 600s;
    proxy_read_timeout 600s;
    
    location / {{{proxy_config}
    }}
    
    location /websocket {{{websocket_config}
    }}
    
    location /longpolling {{
        proxy_pass http://localhost:{odoo_port}/longpolling;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
    
    access_log /var/log/nginx/{deployment.id}_ext_access.log;
    error_log /var/log/nginx/{deployment.id}_ext_error.log;
}}

# ===== INTERNAL DOMAIN WITHOUT AUTHENTICATION =====
server {{
    listen 80;
    server_name {internal_domain};
    
    # No authentication for internal access
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Proxy timeouts
    proxy_connect_timeout 600s;
    proxy_send_timeout 600s;
    proxy_read_timeout 600s;
    
    location / {{{proxy_config}
    }}
    
    location /websocket {{{websocket_config}
    }}
    
    location /longpolling {{
        proxy_pass http://localhost:{odoo_port}/longpolling;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
    
    access_log /var/log/nginx/{deployment.id}_int_access.log;
    error_log /var/log/nginx/{deployment.id}_int_error.log;
}}

# ===== MAILHOG SERVICE =====
server {{
    listen 80;
    server_name mailhog-{external_domain};
    
    auth_basic "OpenSPP Mailhog {deployment.id}";
    auth_basic_user_file /etc/nginx/htpasswd-{deployment.id};
    
    location / {{
        proxy_pass http://localhost:{smtp_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}

server {{
    listen 80;
    server_name mailhog-{deployment.id}.openspp-test.internal;
    
    # No auth for internal
    
    location / {{
        proxy_pass http://localhost:{smtp_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}

# ===== PGWEB SERVICE =====
server {{
    listen 80;
    server_name pgweb-{external_domain};
    
    auth_basic "OpenSPP PGWeb {deployment.id}";
    auth_basic_user_file /etc/nginx/htpasswd-{deployment.id};
    
    location / {{
        proxy_pass http://localhost:{pgweb_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}

server {{
    listen 80;
    server_name pgweb-{deployment.id}.openspp-test.internal;
    
    # No auth for internal
    
    location / {{
        proxy_pass http://localhost:{pgweb_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}
"""
        return config
    
    def save_nginx_config(self, deployment: Deployment) -> bool:
        """Save Nginx configuration to sites-available"""
        config_content = self.generate_nginx_config(deployment)
        config_filename = f"openspp-{deployment.id}.conf"
        config_path = self.nginx_sites_path / config_filename
        
        try:
            # Write to temporary file first
            with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp:
                tmp.write(config_content)
                tmp_path = tmp.name
            
            # Test nginx configuration
            test_result = run_command(
                ["sudo", "nginx", "-t", "-c", "/etc/nginx/nginx.conf"]
            )
            
            if test_result.returncode != 0:
                logger.error(f"Nginx config test failed: {test_result.stderr}")
                os.unlink(tmp_path)
                return False
            
            # Move to nginx sites directory (requires sudo)
            result = run_command(
                ["sudo", "mv", tmp_path, str(config_path)]
            )
            
            if result.returncode != 0:
                logger.error(f"Failed to save nginx config: {result.stderr}")
                return False
            
            # Set proper permissions
            run_command(["sudo", "chmod", "644", str(config_path)])
            
            logger.info(f"Saved nginx config for {deployment.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save nginx config: {e}")
            return False
    
    def enable_site(self, deployment_id: str) -> bool:
        """Enable nginx site by creating symlink"""
        config_filename = f"openspp-{deployment_id}.conf"
        source = self.nginx_sites_path / config_filename
        target = self.nginx_enabled_path / config_filename
        
        try:
            # Create symlink (requires sudo)
            result = run_command(
                ["sudo", "ln", "-sf", str(source), str(target)]
            )
            
            if result.returncode != 0:
                logger.error(f"Failed to enable site: {result.stderr}")
                return False
            
            logger.info(f"Enabled nginx site for {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to enable site: {e}")
            return False
    
    def disable_site(self, deployment_id: str) -> bool:
        """Disable nginx site by removing symlink"""
        config_filename = f"openspp-{deployment_id}.conf"
        target = self.nginx_enabled_path / config_filename
        
        try:
            if target.exists():
                result = run_command(
                    ["sudo", "rm", str(target)]
                )
                
                if result.returncode != 0:
                    logger.error(f"Failed to disable site: {result.stderr}")
                    return False
            
            logger.info(f"Disabled nginx site for {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to disable site: {e}")
            return False
    
    def remove_nginx_config(self, deployment_id: str) -> bool:
        """Remove nginx configuration files"""
        config_filename = f"openspp-{deployment_id}.conf"
        
        # Disable site first
        self.disable_site(deployment_id)
        
        # Remove config file
        config_path = self.nginx_sites_path / config_filename
        
        try:
            if config_path.exists():
                result = run_command(
                    ["sudo", "rm", str(config_path)]
                )
                
                if result.returncode != 0:
                    logger.error(f"Failed to remove config: {result.stderr}")
                    return False
            
            logger.info(f"Removed nginx config for {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to remove nginx config: {e}")
            return False
    
    def reload_nginx(self) -> bool:
        """Reload nginx configuration"""
        try:
            # Test configuration first
            test_result = run_command(
                ["sudo", "nginx", "-t"]
            )
            
            if test_result.returncode != 0:
                logger.error(f"Nginx config test failed: {test_result.stderr}")
                return False
            
            # Reload nginx
            reload_result = run_command(
                ["sudo", "nginx", "-s", "reload"]
            )
            
            if reload_result.returncode != 0:
                logger.error(f"Failed to reload nginx: {reload_result.stderr}")
                return False
            
            logger.info("Nginx reloaded successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to reload nginx: {e}")
            return False
    
    def setup_deployment_domain(self, deployment: Deployment) -> bool:
        """Complete domain setup for a deployment"""
        # Create htpasswd file for authentication
        if deployment.auth_password:
            if not self.create_htpasswd_file(deployment):
                logger.warning(f"Failed to create htpasswd file for {deployment.id}, continuing...")
        
        # Save nginx config
        if not self.save_nginx_config(deployment):
            return False
        
        # Enable site
        if not self.enable_site(deployment.id):
            return False
        
        # Reload nginx
        if not self.reload_nginx():
            return False
        
        return True
    
    def cleanup_deployment_domain(self, deployment_id: str) -> bool:
        """Clean up domain configuration for a deployment"""
        # Remove htpasswd file
        htpasswd_path = Path(f"/etc/nginx/htpasswd-{deployment_id}")
        if htpasswd_path.exists():
            try:
                run_command(["sudo", "rm", str(htpasswd_path)])
                logger.info(f"Removed htpasswd file for {deployment_id}")
            except Exception as e:
                logger.warning(f"Failed to remove htpasswd file: {e}")
        
        # Remove nginx config
        if not self.remove_nginx_config(deployment_id):
            return False
        
        # Reload nginx
        self.reload_nginx()
        
        return True
    
    def generate_all_configs(self, deployments: List[Deployment]) -> int:
        """Generate nginx configs for all deployments"""
        success_count = 0
        
        for deployment in deployments:
            if self.save_nginx_config(deployment):
                if self.enable_site(deployment.id):
                    success_count += 1
        
        # Reload nginx once after all configs
        self.reload_nginx()
        
        return success_count
    
    def check_nginx_installed(self) -> bool:
        """Check if nginx is installed and accessible"""
        result = run_command(["nginx", "-v"], capture_output=True)
        return result.returncode == 0
    
    def get_ssl_certificate_cmd(self, deployment: Deployment) -> List[str]:
        """Get certbot command for SSL certificate"""
        return [
            "sudo", "certbot", "--nginx",
            "-d", deployment.subdomain,
            "-d", f"mailhog-{deployment.subdomain}",
            "-d", f"pgweb-{deployment.subdomain}",
            "--non-interactive",
            "--agree-tos",
            "--email", deployment.tester_email,
            "--redirect"
        ]
    
    def request_ssl_certificate(self, deployment: Deployment) -> bool:
        """Request SSL certificate using certbot"""
        cmd = self.get_ssl_certificate_cmd(deployment)
        
        try:
            result = run_command(cmd)
            
            if result.returncode == 0:
                logger.info(f"SSL certificate obtained for {deployment.subdomain}")
                return True
            else:
                logger.error(f"Failed to obtain SSL certificate: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to request SSL certificate: {e}")
            return False