# ABOUTME: Domain and Nginx configuration manager for deployment subdomains
# ABOUTME: Handles automatic nginx config generation and SSL setup

import os
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional
import tempfile
import shutil

from src.models import Deployment, AppConfig
from src.utils import run_command

logger = logging.getLogger(__name__)


class DomainManager:
    """Manage subdomain configuration and Nginx setup"""
    
    def __init__(self, config: AppConfig):
        self.config = config
        self.nginx_sites_path = Path(config.nginx_config_path)
        self.nginx_enabled_path = self.nginx_sites_path.parent / "sites-enabled"
    
    def generate_subdomain(self, deployment_id: str) -> str:
        """Generate subdomain for deployment"""
        # Simple subdomain: deployment-id.base-domain
        return f"{deployment_id}.{self.config.base_domain}"
    
    def generate_nginx_config(self, deployment: Deployment) -> str:
        """Generate Nginx reverse proxy configuration"""
        # Support both external (test.openspp.org) and internal (openspp-test.internal) domains
        external_domain = deployment.subdomain  # e.g., test1.test.openspp.org
        internal_domain = f"{deployment.id}.openspp-test.internal"  # e.g., penn-qa-farmer.openspp-test.internal
        
        config = f"""# Auto-generated Nginx configuration for {deployment.id}
# Generated by OpenSPP Deployment Manager

server {{
    listen 80;
    server_name {external_domain} {internal_domain};
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Proxy timeouts
    proxy_connect_timeout 600s;
    proxy_send_timeout 600s;
    proxy_read_timeout 600s;
    
    # Main Odoo application
    location / {{
        proxy_pass http://localhost:{deployment.port_mappings['odoo']};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        
        # Odoo specific
        proxy_redirect off;
        
        # Max upload size
        client_max_body_size 100M;
    }}
    
    # Websocket support for live chat and real-time features
    location /websocket {{
        proxy_pass http://localhost:{deployment.port_mappings['odoo']}/websocket;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Websocket timeouts
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
    }}
    
    # Longpolling support
    location /longpolling {{
        proxy_pass http://localhost:{deployment.port_mappings['odoo']}/longpolling;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
    
    # Static files with caching
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {{
        proxy_pass http://localhost:{deployment.port_mappings['odoo']};
        proxy_set_header Host $host;
        proxy_cache_valid 200 90d;
        proxy_cache_valid 404 1m;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}
    
    # Health check endpoint
    location /health {{
        access_log off;
        return 200 "healthy\\n";
        add_header Content-Type text/plain;
    }}
    
    # Deny access to sensitive files
    location ~ /\. {{
        deny all;
        access_log off;
        log_not_found off;
    }}
    
    # Logging
    access_log /var/log/nginx/{deployment.id}_access.log;
    error_log /var/log/nginx/{deployment.id}_error.log;
}}

# Additional services on different ports
server {{
    listen 80;
    server_name mailhog-{external_domain} mailhog-{deployment.id}.openspp-test.internal;
    
    location / {{
        proxy_pass http://localhost:{deployment.port_mappings.get('smtp', deployment.port_base + 25)};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}

server {{
    listen 80;
    server_name pgweb-{external_domain} pgweb-{deployment.id}.openspp-test.internal;
    
    location / {{
        proxy_pass http://localhost:{deployment.port_mappings.get('pgweb', deployment.port_base + 81)};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}
"""
        return config
    
    def save_nginx_config(self, deployment: Deployment) -> bool:
        """Save Nginx configuration to sites-available"""
        config_content = self.generate_nginx_config(deployment)
        config_filename = f"openspp-{deployment.id}.conf"
        config_path = self.nginx_sites_path / config_filename
        
        try:
            # Write to temporary file first
            with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp:
                tmp.write(config_content)
                tmp_path = tmp.name
            
            # Test nginx configuration
            test_result = run_command(
                ["sudo", "nginx", "-t", "-c", "/etc/nginx/nginx.conf"]
            )
            
            if test_result.returncode != 0:
                logger.error(f"Nginx config test failed: {test_result.stderr}")
                os.unlink(tmp_path)
                return False
            
            # Move to nginx sites directory (requires sudo)
            result = run_command(
                ["sudo", "mv", tmp_path, str(config_path)]
            )
            
            if result.returncode != 0:
                logger.error(f"Failed to save nginx config: {result.stderr}")
                return False
            
            # Set proper permissions
            run_command(["sudo", "chmod", "644", str(config_path)])
            
            logger.info(f"Saved nginx config for {deployment.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save nginx config: {e}")
            return False
    
    def enable_site(self, deployment_id: str) -> bool:
        """Enable nginx site by creating symlink"""
        config_filename = f"openspp-{deployment_id}.conf"
        source = self.nginx_sites_path / config_filename
        target = self.nginx_enabled_path / config_filename
        
        try:
            # Create symlink (requires sudo)
            result = run_command(
                ["sudo", "ln", "-sf", str(source), str(target)]
            )
            
            if result.returncode != 0:
                logger.error(f"Failed to enable site: {result.stderr}")
                return False
            
            logger.info(f"Enabled nginx site for {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to enable site: {e}")
            return False
    
    def disable_site(self, deployment_id: str) -> bool:
        """Disable nginx site by removing symlink"""
        config_filename = f"openspp-{deployment_id}.conf"
        target = self.nginx_enabled_path / config_filename
        
        try:
            if target.exists():
                result = run_command(
                    ["sudo", "rm", str(target)]
                )
                
                if result.returncode != 0:
                    logger.error(f"Failed to disable site: {result.stderr}")
                    return False
            
            logger.info(f"Disabled nginx site for {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to disable site: {e}")
            return False
    
    def remove_nginx_config(self, deployment_id: str) -> bool:
        """Remove nginx configuration files"""
        config_filename = f"openspp-{deployment_id}.conf"
        
        # Disable site first
        self.disable_site(deployment_id)
        
        # Remove config file
        config_path = self.nginx_sites_path / config_filename
        
        try:
            if config_path.exists():
                result = run_command(
                    ["sudo", "rm", str(config_path)]
                )
                
                if result.returncode != 0:
                    logger.error(f"Failed to remove config: {result.stderr}")
                    return False
            
            logger.info(f"Removed nginx config for {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to remove nginx config: {e}")
            return False
    
    def reload_nginx(self) -> bool:
        """Reload nginx configuration"""
        try:
            # Test configuration first
            test_result = run_command(
                ["sudo", "nginx", "-t"]
            )
            
            if test_result.returncode != 0:
                logger.error(f"Nginx config test failed: {test_result.stderr}")
                return False
            
            # Reload nginx
            reload_result = run_command(
                ["sudo", "nginx", "-s", "reload"]
            )
            
            if reload_result.returncode != 0:
                logger.error(f"Failed to reload nginx: {reload_result.stderr}")
                return False
            
            logger.info("Nginx reloaded successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to reload nginx: {e}")
            return False
    
    def setup_deployment_domain(self, deployment: Deployment) -> bool:
        """Complete domain setup for a deployment"""
        # Save nginx config
        if not self.save_nginx_config(deployment):
            return False
        
        # Enable site
        if not self.enable_site(deployment.id):
            return False
        
        # Reload nginx
        if not self.reload_nginx():
            return False
        
        return True
    
    def cleanup_deployment_domain(self, deployment_id: str) -> bool:
        """Clean up domain configuration for a deployment"""
        # Remove nginx config
        if not self.remove_nginx_config(deployment_id):
            return False
        
        # Reload nginx
        self.reload_nginx()
        
        return True
    
    def generate_all_configs(self, deployments: List[Deployment]) -> int:
        """Generate nginx configs for all deployments"""
        success_count = 0
        
        for deployment in deployments:
            if self.save_nginx_config(deployment):
                if self.enable_site(deployment.id):
                    success_count += 1
        
        # Reload nginx once after all configs
        self.reload_nginx()
        
        return success_count
    
    def check_nginx_installed(self) -> bool:
        """Check if nginx is installed and accessible"""
        result = run_command(["nginx", "-v"], capture_output=True)
        return result.returncode == 0
    
    def get_ssl_certificate_cmd(self, deployment: Deployment) -> List[str]:
        """Get certbot command for SSL certificate"""
        return [
            "sudo", "certbot", "--nginx",
            "-d", deployment.subdomain,
            "-d", f"mailhog-{deployment.subdomain}",
            "-d", f"pgweb-{deployment.subdomain}",
            "--non-interactive",
            "--agree-tos",
            "--email", deployment.tester_email,
            "--redirect"
        ]
    
    def request_ssl_certificate(self, deployment: Deployment) -> bool:
        """Request SSL certificate using certbot"""
        cmd = self.get_ssl_certificate_cmd(deployment)
        
        try:
            result = run_command(cmd)
            
            if result.returncode == 0:
                logger.info(f"SSL certificate obtained for {deployment.subdomain}")
                return True
            else:
                logger.error(f"Failed to obtain SSL certificate: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to request SSL certificate: {e}")
            return False